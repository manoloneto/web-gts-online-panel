################################################################################
#
# GTS System                  Version 3.0.0 RELEASE
# By Hansiec and Manoel Afonso 
#
# CHANGE LOG FOR THIS VERSION:
# - Adaptation of the original script to work on v17.x of PokÃ©mon Essentials
# - Set to work with GTS Online Panel by Hills Tech
# - Performance improvement
# - Some minor bugs fixed
#
# Special Thanks to Saving Raven for providing graphics and testing
# CREDITS REQUIRED
#
################################################################################
#
# NOTICE: If a bug occurs, please state the message of the bug.
#
# Installation:
#   * Create a new code session above Main and paste this script there;
#   * Go to http://gts.hillstech.co and create a user account;
#   * Go to the "new game" tab on the site and create a new game;
#   * Get the game ID that was generated on the site and paste it 
#     into the GAMEID variable in this script;
#   * Done.
#
# How To Use:
#   * Install
#   * Call "GTS.open"
#   * Report if any bugs uccor
#
# Settings:
#   * URL - The url link of the online panel, don't change this.
#   * SPECIES_SHOWN - Set to "All", "Owned", or "Seen" - this sets the available
#       species you can search for.
#   * SORT_MODE - Set to "Alphabetical" or "Regional" - How species are arranged
#       during species finding.
#   * GAME_CODE - A special Game Code, if you happen to trade with a game with
#       a different game code, the found map would be "Faraway Place".
#
################################################################################

module GTSSettings 

  GAMEID = 0 # paste the ID of your game here

  URL = "http://gts.hillstech.co/api.php?i=" # don't change this

  SPECIES_SHOWN = "All" # All/Seen/Owned Species you can search for
  SORT_MODE = "Alphabetical" # Alphabetical/Regional How species are arranged
  BLACK_LIST = [] # Pokemon Species of which cannot be selected to search for

  GAME_CODE = "" # Please use a custom Game Code
                 # It IS case Sensitive and can be any length, this is to define
                 # Games as different from each other.
                 
  KEEP_OLD_IDS = true # If this is set to false, instead of keeping your old
                      # online ID it creates you a new one, this means that
                      # it can cause a table in the MySQL server to be flooded
                      # with someone who constantly does new game and uploads a
                      # pokemon to the server. This should only be done for
                      # testing purposes

end

# Temporary boolean, DO NOT REMOVE
$TempBool = false

module GTS
  ##### Main Method
  def self.open
    scene = Scene_GTS.new
    scene.main
  end
  
  #### Brings up a summary of your uploaded pokemon (also allows you to delete it)
  def self.summary
    if GTSCore.isTaken
      newpoke = GTSCore.downloadPokemon($PokemonGlobal.onlineID).to_pokemon
      if finishTrade($PokemonGlobal.onlinePokemon, newpoke, false)
        pbAddPokemonSilent(newpoke)
        $PokemonGlobal.onlinePokemon = nil
        pbSave
      end
      return
    end
    pbFadeOutIn(99999){
      scene=PokemonSummary_Scene.new
      screen=PokemonSummaryScreen.new(scene)
      screen.pbStartScreen([$PokemonGlobal.onlinePokemon],0)
    }
    if Kernel.pbConfirmMessageSerious(_INTL("Do you want to withdraw your "+
      "pokemon from GTS?"))
      if Kernel.pbConfirmMessageSerious(_INTL("Are you sure you want to "+
        "withdraw your pokemon?"))
        if GTSCore.deletePokemon
          pbAddPokemonSilent($PokemonGlobal.onlinePokemon)
          $PokemonGlobal.onlinePokemon = nil
          $TempBool = true
          pbSave
          # Long story short, we save before we show the message to help prevent
          # pokemon from being deleted by restarting, but if the game is restarted,
          # we don't want this message
          if $TempBool
            Kernel.pbMessage(_INTL("Pokemon withdrawn, please be aware that "+
            "your pokemon may have had been taken by now."))
          end
        end
      end
    end
  end
  
  ##### Finishes the GTS trade
  def self.finishTrade(myPokemon, newpoke, searching, id=nil)
    $Trainer.seen[newpoke.species]=true
    $Trainer.owned[newpoke.species]=true
    pbSeenForm(newpoke)
    pbFadeOutInWithMusic(99999){
      evo=PokemonTradeScene.new
      evo.pbStartScreen(myPokemon,newpoke,$Trainer.name,newpoke.ot)
      evo.pbTrade
      evo.pbEndScreen
    }
    if !newpoke.game_code || newpoke.game_code != GTSSettings::GAME_CODE
      newpoke.obtainText = "Faraway Place"
    end
    newpoke.obtainMode = 2 # Traded
    if searching
      if GTSCore.setTaken(id) && GTSCore.uploadNewPokemon(id, myPokemon)
        pbAddPokemonSilent(newpoke)
        pbSave
        return true
      end
      return false
    else
      pbSave
      return GTSCore.deletePokemon(false)
    end
  end
  
  
  ##### Brings up all species of pokemon of the given index of the given sort mode
  def self.orderSpecies(index)
    speciesList = []
    commands = ["Cancel"]
    if GTSSettings::SORT_MODE == "Alphabetical"
      l = "A"
      l[0] += index if !index.is_a?(String)
      letter = index.is_a?(String) ? index : l
      for i in 1..PBSpecies.maxValue
        show = true
        show = false if !$Trainer.seen[i] && GTSSettings::SPECIES_SHOWN == "Seen"
        show = false if !$Trainer.owned[i] && GTSSettings::SPECIES_SHOWN == "Owned"
        for j in GTSSettings::BLACK_LIST
          show = false if i == j
          break if !show
        end
        speciesList.push(i) if PBSpecies.getName(i)[0] == letter[0] && show
      end
    elsif GTSSettings::SORT_MODE == "Regional"
      realIndex = -1
      regions = pbDexNames
      for i in 0...regions.length
        if regions[i].is_a?(Array)
          if regions[i][0] == index
            realIndex = regions[i][1]
          end
        end
      end
      if realIndex != -1
        sl = pbAllRegionalSpecies(realIndex)
        for i in sl
          show = true
          show = false if !$Trainer.seen[i] &&
          GTSSettings::SPECIES_SHOWN == "Seen"
          show = false if !$Trainer.owned[i] &&
          GTSSettings::SPECIES_SHOWN == "Owned"
          for j in GTSSettings::BLACK_LIST
            show = false if i == j
            break if !show
          end
          speciesList.push(i) if show
        end
      else
        for i in 1..PBSpecies.maxValue
          show = true
          show = false if !$Trainer.seen[i] &&
          GTSSettings::SPECIES_SHOWN == "Seen"
          show = false if !$Trainer.owned[i] &&
          GTSSettings::SPECIES_SHOWN == "Owned"
          for j in GTSSettings::BLACK_LIST
            show = false if i == j
            break if !show
          end
          speciesList.push(i) if show
        end
      end
    end
    for i in speciesList
      commands.push("#{i}: #{PBSpecies.getName(i)}") if i > 0
    end
    if commands.length == 1
      Kernel.pbMessage(_INTL("No species found"))
      return [0, 0]
    end
    c = Kernel.pbMessage("Select a Species", commands, 0, nil, 1)
    
    x = speciesList[c - 1]
    if x.is_a?(Array)
      x = x[0]
    end
    return [c == 0 ? -1 : x, c]
  end
  
end
################################################################################
# GTS Scenes
# By A Dork of Pork
# Scenes For GTS
################################################################################

######## GTS Button, A Basic options button for our GTS System
class GTS_Button < SpriteWrapper
  def initialize(x,y,name="",index=0,viewport=nil)
    super(viewport)
    @index=index
    @name=name
    @selected=false
    self.x=x
    self.y=y
    update
  end

  def dispose
    super
  end

  def refresh
    self.bitmap.dispose if self.bitmap
    self.bitmap = Bitmap.new("Graphics/Pictures/GTS/Options_bar")
    pbSetSystemFont(self.bitmap)
    textpos=[
       [@name,self.bitmap.width/2,1,2,Color.new(248,248,248),Color.new(40,40,40)],
    ]
    pbDrawTextPositions(self.bitmap,textpos)
  end

  def update
    refresh
    super
  end
end

########## GTS Search Method Selection
class GTSSearchMethod
  def initialize
    @exit = false
    @index = 0
  end
  
  def create_spriteset
    pbDisposeSpriteHash(@sprites) if @sprites
    @sprites = {}
    @sprites["background"] = IconSprite.new
    @sprites["background"].setBitmap("Graphics/Pictures/GTS/Background")
    
    pbSetSystemFont(@sprites["background"].bitmap)
    textpos=[          
       ["Select Search Method",50,6,0,Color.new(248,248,248),Color.new(40,40,40)],
       ["Online ID: #{$PokemonGlobal.onlineID}",350,6,2,Color.new(248,248,248),
       Color.new(40,40,40)],
    ]
    pbDrawTextPositions(@sprites["background"].bitmap,textpos)
    
    @sprites["0"] = GTS_Button.new(Graphics.width/2, 50, "By Wanted")
    @sprites["0"].x -= @sprites["0"].bitmap.width / 2
    
    @sprites["1"] = GTS_Button.new(Graphics.width/2, 110, "By Pokemon")
    @sprites["1"].x -= @sprites["1"].bitmap.width / 2
    
    @sprites["2"] = GTS_Button.new(Graphics.width/2, 170, "By ID")
    @sprites["2"].x -= @sprites["2"].bitmap.width / 2
    
    @sprites["3"] = GTS_Button.new(Graphics.width/2, 230, "Exit")
    @sprites["3"].x -= @sprites["3"].bitmap.width / 2
    
    bit = Bitmap.new("Graphics/Pictures/GTS/Select")
    @sprites["selection_l"] = IconSprite.new
    @sprites["selection_l"].bitmap = Bitmap.new(16, 46)
    @sprites["selection_l"].bitmap.blt(0, 0, bit, Rect.new(0, 0, 16, 16))
    @sprites["selection_l"].bitmap.blt(0, 23, bit, Rect.new(0, 16, 16, 32))
    
    @sprites["selection_r"] = IconSprite.new
    @sprites["selection_r"].bitmap = Bitmap.new(16, 46)
    @sprites["selection_r"].bitmap.blt(0, 0, bit, Rect.new(16, 0, 32, 16))
    @sprites["selection_r"].bitmap.blt(0, 23, bit, Rect.new(16, 16, 32, 32))
    
    @sprites["selection_l"].x = @sprites["#{@index}"].x-2
    @sprites["selection_l"].y = @sprites["#{@index}"].y-2
    @sprites["selection_r"].x = @sprites["#{@index}"].x+
    @sprites["#{@index}"].bitmap.width-18
    @sprites["selection_r"].y = @sprites["#{@index}"].y-2
    
  end
  
  def main
    Graphics.freeze
    create_spriteset
    Graphics.transition
    loop do
      Graphics.update
      Input.update
      update
      break if @exit
    end
    Graphics.freeze
    pbDisposeSpriteHash(@sprites)
  end
  
  def update
    pbUpdateSpriteHash(@sprites)
    @sprites["selection_l"].x = @sprites["#{@index}"].x-2
    @sprites["selection_l"].y = @sprites["#{@index}"].y-2
    @sprites["selection_r"].x = @sprites["#{@index}"].x+
    @sprites["#{@index}"].bitmap.width-18
    @sprites["selection_r"].y = @sprites["#{@index}"].y-2
    if Input.trigger?(Input::UP)
      @index -= 1
      if @index < 0
        @index = 3
      end
    elsif Input.trigger?(Input::DOWN)
      @index += 1
      if @index > 3
        @index = 0
      end
    end
    if (Input.trigger?(Input::B))
      pbPlayCancelSE
      @exit = true
    elsif (Input.trigger?(Input::C))
      pbPlayDecisionSE
      do_command
    end
  end
  
  def do_command
    if @index == 0
      Graphics.freeze
      scene = GTSWantedData.new
      @sprites["background"].dispose
      data=scene.main
      create_spriteset
      Graphics.transition
      return if !data.is_a?(Array)
      list = GTSCore.getPokemonList(data)
      if list[0] == "nothing"
        Kernel.pbMessage(_INTL("No Pokemon was found."))
      else
        pokemonList = []
        for i in list
          pokemonList.push(GTSCore.downloadPokemon(i).to_pokemon)
        end
        loop do
          scene=PokemonSummaryScene.new
          screen=PokemonSummary.new(scene)
          index = screen.pbStartGTSScreen(pokemonList,0)
          if index == false
            break
          else
            wantedData = GTSCore.downloadWantedData(list[index])
            for i in 0...wantedData.length
              wantedData[i] = wantedData[i].to_i
            end
            scene=PokemonSummaryScene.new
            screen=PokemonSummary.new(scene)
            takes = screen.pbStartGTSWantedScreen(wantedData,0)
            if takes
              pbFadeOutIn(99999){
               scene=PokemonStorageScene.new
               screen=PokemonStorageScreen.new(scene,$PokemonStorage)
               $choice = choice = screen.pbChoosePokemon
              }
              choice = $choice
              if choice == nil
                break
              else
                party = choice[0] == -1
                pkmn = $Trainer.party[choice[1]].clone if party
                pkmn = $PokemonStorage[choice[0]][choice[1]].clone if !party
                
                if pkmn.species != wantedData[0] || pkmn.level < wantedData[1] ||
                  pkmn.level > wantedData[2] ||
                  (wantedData[3] != -1 && pkmn.gender != wantedData[3])
                  Kernel.pbMessage(_INTL("The selected pokemon does not match the"+
                  " wanted requirments."))
                else      
                  if GTS.finishTrade(pkmn, pokemonList[index], true, list[index])
                    if party
                      pbRemovePokemonAt(choice[1])
                    else
                      $PokemonStorage[choice[0]][choice[1]] = nil
                    end
                    pbSave
                    return true
                  end
                end
              end
            end
          end
        end
      end
    elsif @index == 1
      Kernel.pbMessage(_INTL("To Continue, please select a pokemon of yours,"+
      " we will match it up with any possible matches and allow you to choose a"+
      " match."))
      pbFadeOutIn(99999){
       scene=PokemonStorageScene.new
       screen=PokemonStorageScreen.new(scene,$PokemonStorage)
       $choice = choice = screen.pbChoosePokemon
      }
      choice = $choice
      if choice == nil
        return
      else
        party = choice[0] == -1
        pkmn = $Trainer.party[choice[1]].clone
        pkmn = $PokemonStorage[choice[0]][choice[1]].clone if !party
        if pkmn
          list = GTSCore.getPokemonListFromWanted(pkmn)
          if list[0] == "nothing"
            Kernel.pbMessage(_INTL("No Pokemon was found."))
          else
            pokemonList = []
            for i in list
              pokemonList.push(GTSCore.downloadPokemon(i).to_pokemon)
            end
            loop do
              scene=PokemonSummaryScene.new
              screen=PokemonSummary.new(scene)
              index = screen.pbStartGTSScreen(pokemonList,0)
              if index == false
                break
              else
                wantedData = GTSCore.downloadWantedData(list[index])
                for i in 0...wantedData.length
                  wantedData[i] = wantedData[i].to_i
                end
                Kernel.pbMessage(_INTL("To confirm, this is the wanted data."))
                scene=PokemonSummaryScene.new
                screen=PokemonSummary.new(scene)
                takes = screen.pbStartGTSWantedScreen(wantedData,0)
                if takes
                  if GTS.finishTrade(pkmn, pokemonList[index], true, list[index])
                    if party
                      pbRemovePokemonAt(choice[1])
                    else
                      $PokemonStorage[choice[0]][choice[1]] = nil
                    end
                    pbSave
                    return true
                  end
                else
                  break
                end
              end
            end
          end
        end
      end
    elsif @index == 2
      loop do
        params=ChooseNumberParams.new
        params.setRange(1,99999999)
        params.setInitialValue(1)
        params.setCancelValue(-1)
        id=Kernel.pbMessageChooseNumber(
           _INTL("Select the online ID."),params)
        return if id < 1
        if id == $PokemonGlobal.onlineID
          Kernel.pbMessage(_INTL("You cannot search by your own online ID!"))
        else
          break
        end
      end
      if !GTSCore.hasPokemonUploaded?(id)
        Kernel.pbMessage(_INTL("No Pokemon with this online ID exists!"))
        return
      end
      gpkmn = GTSCore.downloadPokemon(id).to_pokemon
      wantedData = GTSCore.downloadWantedData(id)
      for i in 0...wantedData.length
        wantedData[i] = wantedData[i].to_i
      end
      scene=PokemonSummaryScene.new
      screen=PokemonSummary.new(scene)
      index = screen.pbStartGTSScreen([gpkmn],0)
      if index
        scene=PokemonSummaryScene.new
        screen=PokemonSummary.new(scene)
        takes = screen.pbStartGTSWantedScreen(wantedData,0)
        if takes
          pbFadeOutIn(99999){
           scene=PokemonStorageScene.new
           screen=PokemonStorageScreen.new(scene,$PokemonStorage)
           $choice = choice = screen.pbChoosePokemon
          }
          choice = $choice
          if choice == nil
            return
          else
            party = choice[0] == -1
            pkmn = $Trainer.party[choice[1]].clone
            pkmn = $PokemonStorage[choice[0]][choice[1]].clone if !party
            
            if pkmn.species != wantedData[0] || pkmn.level < wantedData[1] ||
              pkmn.level > wantedData[2] ||
              (wantedData[3] != -1 && pkmn.gender != wantedData[3])
              Kernel.pbMessage(_INTL("The selected pokemon does not match the"+
              " wanted requirments."))
            else      
              if GTS.finishTrade(pkmn, gpkmn, true, id)
                if party
                  pbRemovePokemonAt(choice[1])
                else
                  $PokemonStorage[choice[0]][choice[1]] = nil
                end
                pbSave
                return true
              end
            end
          end
        end
      end
    else
      @exit = true
    end
  end
end

########## GTS Wanted Data, shows a screen on which you can create wanted data
class GTSWantedData
  def initialize
    @exit = false
    @wanted_data = [-1, 1, 100, -1]
    @index = 0
  end
  
  def create_spriteset
    pbDisposeSpriteHash(@sprites) if @sprites
    @sprites = {}
    
    @sprites["background"] = IconSprite.new
    @sprites["background"].setBitmap("Graphics/Pictures/GTS/Background")
    
    pbSetSystemFont(@sprites["background"].bitmap)
    textpos=[          
       ["Pokemon Wanted Data",50,6,0,Color.new(248,248,248),Color.new(40,40,40)],
       ["Online ID: #{$PokemonGlobal.onlineID}",350,6,2,Color.new(248,248,248),
       Color.new(40,40,40)],
    ]
    pbDrawTextPositions(@sprites["background"].bitmap,textpos)
    
    @sprites["0"] = IconSprite.new
    @sprites["0"].setBitmap("Graphics/Pictures/GTS/Pokemon_bar")
    @sprites["0"].x = Graphics.width / 2
    @sprites["0"].x -= @sprites["0"].bitmap.width / 2
    @sprites["0"].y = 50
    
    @sprites["0t"] = IconSprite.new
    @sprites["0t"].bitmap = Bitmap.new(@sprites["0"].bitmap.width, 
    @sprites["0"].bitmap.height)
    @sprites["0t"].x = @sprites["0"].x
    @sprites["0t"].y = @sprites["0"].y
    
    @sprites["1"] = IconSprite.new
    @sprites["1"].setBitmap("Graphics/Pictures/GTS/Gender_bar")
    @sprites["1"].x = Graphics.width / 2
    @sprites["1"].x -= @sprites["1"].bitmap.width / 2
    @sprites["1"].y = 110
    
    @sprites["1t"] = IconSprite.new
    @sprites["1t"].bitmap = Bitmap.new(@sprites["1"].bitmap.width, 
    @sprites["1"].bitmap.height)
    @sprites["1t"].x = @sprites["1"].x
    @sprites["1t"].y = @sprites["1"].y
    
    @sprites["2"] = IconSprite.new
    @sprites["2"].setBitmap("Graphics/Pictures/GTS/Level_bar")
    @sprites["2"].x = Graphics.width / 2
    @sprites["2"].x -= @sprites["2"].bitmap.width / 2
    @sprites["2"].y = 170
    
    @sprites["2t"] = IconSprite.new
    @sprites["2t"].bitmap = Bitmap.new(@sprites["2"].bitmap.width, 
    @sprites["2"].bitmap.height)
    @sprites["2t"].x = @sprites["2"].x
    @sprites["2t"].y = @sprites["2"].y
    
    @sprites["3"] = IconSprite.new
    @sprites["3"].setBitmap("Graphics/Pictures/GTS/Search_bar")
    @sprites["3"].x = Graphics.width / 2
    @sprites["3"].x -= @sprites["3"].bitmap.width / 2
    @sprites["3"].y = 230
    
    @sprites["3t"] = IconSprite.new
    @sprites["3t"].bitmap = Bitmap.new(@sprites["3"].bitmap.width, 
    @sprites["3"].bitmap.height)
    @sprites["3t"].x = @sprites["3"].x
    @sprites["3t"].y = @sprites["3"].y
    
    @sprites["4"] = GTS_Button.new(Graphics.width/2, 290, "Back")
    @sprites["4"].x -= @sprites["4"].bitmap.width / 2
    
    pbSetSystemFont(@sprites["0"].bitmap)
    textpos=[          
       ["Pokemon You Want",50,0,0,Color.new(248,248,248),Color.new(40,40,40)],
    ]
    pbDrawTextPositions(@sprites["0"].bitmap,textpos)
    
    pbSetSystemFont(@sprites["1"].bitmap)
    textpos=[          
       ["Gender",75,0,0,Color.new(248,248,248),Color.new(40,40,40)],
    ]
    pbDrawTextPositions(@sprites["1"].bitmap,textpos)
    
    pbSetSystemFont(@sprites["2"].bitmap)
    textpos=[          
       ["Level Range",50,0,0,Color.new(248,248,248),Color.new(40,40,40)],
    ]
    pbDrawTextPositions(@sprites["2"].bitmap,textpos)
    
    pbSetSystemFont(@sprites["3"].bitmap)
    textpos=[          
       ["Search with these Conditions!",
       @sprites["3"].bitmap.width / 2, 2,2,Color.new(248,248,248),
       Color.new(40,40,40)],
    ]
    pbDrawTextPositions(@sprites["3"].bitmap,textpos)
    
    bit = Bitmap.new("Graphics/Pictures/GTS/Select")
    @sprites["selection_l"] = IconSprite.new
    @sprites["selection_l"].bitmap = Bitmap.new(16, 46)
    @sprites["selection_l"].bitmap.blt(0, 0, bit, Rect.new(0, 0, 16, 16))
    @sprites["selection_l"].bitmap.blt(0, 23, bit, Rect.new(0, 16, 16, 32))
    
    @sprites["selection_r"] = IconSprite.new
    @sprites["selection_r"].bitmap = Bitmap.new(16, 46)
    @sprites["selection_r"].bitmap.blt(0, 0, bit, Rect.new(16, 0, 32, 16))
    @sprites["selection_r"].bitmap.blt(0, 23, bit, Rect.new(16, 16, 32, 32))
    
    @sprites["selection_l"].x = @sprites["#{@index}"].x-2
    @sprites["selection_l"].y = @sprites["#{@index}"].y-2
    @sprites["selection_r"].x = @sprites["#{@index}"].x+
    @sprites["#{@index}"].bitmap.width-18
    @sprites["selection_r"].y = @sprites["#{@index}"].y-2
    
    drawWantedData
  end
  
  def drawWantedData
    @sprites["0t"].bitmap.clear
    s = "????"
    s = PBSpecies.getName(@wanted_data[0]) if @wanted_data[0] > 0
    pbSetSystemFont(@sprites["0t"].bitmap)
    textpos=[          
       [s,350,4,2,Color.new(248,248,248),Color.new(40,40,40)],
    ]
    pbDrawTextPositions(@sprites["0t"].bitmap,textpos)
    
    @sprites["1t"].bitmap.clear
    g = "Either"
    g = "Male" if @wanted_data[3] == 0
    g = "Female" if @wanted_data[3] == 1
    pbSetSystemFont(@sprites["1t"].bitmap)
    textpos=[          
       [g,325,2,2,Color.new(248,248,248),Color.new(40,40,40)],
    ]
    pbDrawTextPositions(@sprites["1t"].bitmap,textpos)
    
    @sprites["2t"].bitmap.clear
    lr = "#{@wanted_data[1]} To #{@wanted_data[2]}"
    pbSetSystemFont(@sprites["2t"].bitmap)
    textpos=[          
       [lr,325,4,2,Color.new(248,248,248),Color.new(40,40,40)],
    ]
    pbDrawTextPositions(@sprites["2t"].bitmap,textpos)
  end
  
  def main
    Graphics.freeze
    create_spriteset
    Graphics.transition
    loop do
      Graphics.update
      Input.update
      update
      break if @exit
    end
    Graphics.freeze
    pbDisposeSpriteHash(@sprites)
    return @wanted_data 
  end
  
  def update
    pbUpdateSpriteHash(@sprites)
    
    @sprites["selection_l"].x = @sprites["#{@index}"].x-2
    @sprites["selection_l"].y = @sprites["#{@index}"].y-2
    @sprites["selection_r"].x = @sprites["#{@index}"].x+
    @sprites["#{@index}"].bitmap.width-18
    @sprites["selection_r"].y = @sprites["#{@index}"].y-2
    
    if Input.trigger?(Input::B)
      pbPlayCancelSE
      @wanted_data = -1
      @exit = true
    end
    
    if Input.trigger?(Input::C)
      pbPlayDecisionSE
      do_command
    end
    
    if Input.trigger?(Input::UP)
      @index -= 1
      if @index < 0
        @index = 4
      end
    end
    if Input.trigger?(Input::DOWN)
      @index += 1
      if @index > 4
        @index = 0
      end
    end
  end
  
  def do_command
    if @index == 0
      msg = ""
      commands2 = ["Cancel"]
      if GTSSettings::SORT_MODE == "Alphabetical"
        sL = "A"
        for i in 0...26
          s = sL.clone
          s[0] += i
          commands2.push(s)
        end
        msg = "Choose a Letter."
      elsif GTSSettings::SORT_MODE == "Regional"
        dexNames = pbDexNames
        for i in dexNames
          if i.is_a?(String)
            name = i
          else
            name = i[0]
          end
          commands2.push(name)
        end
        msg = "Choose a Pokedex."
      end
      c2 = Kernel.pbMessage(msg, commands2, 0, nil, 1)
      if c2 > 0
        s = GTS.orderSpecies(commands2[c2])
        @wanted_data[0] = s[0] if s[0] > 0
      end
    elsif @index == 1
      cmds = ["Either", "Male", "Female"]
      @wanted_data[3] = Kernel.pbMessage("Which gender do you want", cmds,
      @wanted_data[3] + 1, nil, @wanted_data[3]+1) - 1
    elsif @index == 2
      params=ChooseNumberParams.new
      params.setRange(1,PBExperience::MAXLEVEL)
      params.setInitialValue(@wanted_data[1])
      params.setCancelValue(@wanted_data[1])
      @wanted_data[1]=Kernel.pbMessageChooseNumber(
         _INTL("Set the Minimum wanted level."),params)
      params=ChooseNumberParams.new
      params.setRange(1,PBExperience::MAXLEVEL)
      params.setInitialValue(@wanted_data[2])
      params.setCancelValue(@wanted_data[2])
      @wanted_data[2]=Kernel.pbMessageChooseNumber(
         _INTL("Set the Maximum wanted level."),params)
    elsif @index == 3
      if @wanted_data[0] > 0
        @exit = true
      else
        pbPlayCancelSE
      end
    elsif @index == 4
      @wanted_data = -1
      @exit = true
    end
    drawWantedData
  end
end


########## Scene GTS Main GTS Functionality here.
class Scene_GTS
  def initialize
    @index = 0
    @exit = false
    @uploaded = GTSCore.hasPokemonUploaded?
  end
  
  def create_spriteset
    pbDisposeSpriteHash(@sprites) if @sprites
    @sprites = {}
    @sprites["background"] = IconSprite.new
    @sprites["background"].setBitmap("Graphics/Pictures/GTS/Background")
    
    pbSetSystemFont(@sprites["background"].bitmap)
    textpos=[          
       ["GTS",50,6,2,Color.new(248,248,248),Color.new(40,40,40)],
       ["Online ID: #{$PokemonGlobal.onlineID}",350,6,2,Color.new(248,248,248),
       Color.new(40,40,40)],
    ]
    pbDrawTextPositions(@sprites["background"].bitmap,textpos)
    
    @sprites["0"] = GTS_Button.new(Graphics.width/2, 100, "Search")
    @sprites["0"].x -= @sprites["0"].bitmap.width / 2
    
    t = "Deposit"
    t = "Summary" if @uploaded
    
    @sprites["1"] = GTS_Button.new(Graphics.width/2, 200, t)
    @sprites["1"].x -= @sprites["1"].bitmap.width / 2
    
    @sprites["2"] = GTS_Button.new(Graphics.width/2, 300, "Exit")
    @sprites["2"].x -= @sprites["2"].bitmap.width / 2
    
    bit = Bitmap.new("Graphics/Pictures/GTS/Select")
    @sprites["selection_l"] = IconSprite.new
    @sprites["selection_l"].bitmap = Bitmap.new(16, 46)
    @sprites["selection_l"].bitmap.blt(0, 0, bit, Rect.new(0, 0, 16, 16))
    @sprites["selection_l"].bitmap.blt(0, 23, bit, Rect.new(0, 16, 16, 32))
    
    @sprites["selection_r"] = IconSprite.new
    @sprites["selection_r"].bitmap = Bitmap.new(16, 46)
    @sprites["selection_r"].bitmap.blt(0, 0, bit, Rect.new(16, 0, 32, 16))
    @sprites["selection_r"].bitmap.blt(0, 23, bit, Rect.new(16, 16, 32, 32))
    
    @sprites["selection_l"].x = @sprites["#{@index}"].x-2
    @sprites["selection_l"].y = @sprites["#{@index}"].y-2
    @sprites["selection_r"].x = @sprites["#{@index}"].x+
    @sprites["0"].bitmap.width-18
    @sprites["selection_r"].y = @sprites["#{@index}"].y-2
    
  end
  
  def main
    Graphics.freeze
    create_spriteset
    Graphics.transition
    loop do
      break if @exit
      Graphics.update
      Input.update
      update
    end
    Graphics.freeze
    pbDisposeSpriteHash(@sprites)
    Graphics.transition
  end
  
  def update
    pbUpdateSpriteHash(@sprites)
    @sprites["selection_l"].x = @sprites["#{@index}"].x-2
    @sprites["selection_l"].y = @sprites["#{@index}"].y-2
    @sprites["selection_r"].x = @sprites["#{@index}"].x+
    @sprites["0"].bitmap.width-18
    @sprites["selection_r"].y = @sprites["#{@index}"].y-2
    
    if Input.trigger?(Input::UP)
      @index -= 1
      if @index < 0
        @index = 2
      end
    end
    
    if Input.trigger?(Input::DOWN)
      @index += 1
      if @index > 2
        @index = 0
      end
    end
    
    if Input.trigger?(Input::B)
      choices = []
      choices.push(_INTL("Yes"))
      choices.push(_INTL("No"))
      command=Kernel.pbMessage("Are you sure you want to quit GTS?",choices,choices.length)
      if command == 0
        pbPlayCancelSE
        @exit = true
      end
    end
    
    if Input.trigger?(Input::C)
      pbPlayDecisionSE
      do_command
    end
    
  end
  
  def do_command
    if @index == 0
      Graphics.freeze
      scene = GTSSearchMethod.new
      @sprites["background"].dispose
      data = scene.main
      create_spriteset
      Graphics.transition
    elsif @index == 1
      if @uploaded
        GTS.summary
        @uploaded = GTSCore.hasPokemonUploaded?
        create_spriteset
      else
        pbFadeOutIn(99999){
         scene=PokemonStorageScene.new
         screen=PokemonStorageScreen.new(scene,$PokemonStorage)
         $choice = screen.pbChoosePokemon
        }
        choice = $choice
        return false if choice == nil
        pkmn = $Trainer.party[choice[1]]
        pkmn = $PokemonStorage[choice[0]][choice[1]] if choice[0] >= 0
        if choice[0] == -1
          if $Trainer.party.length == 1
            Kernel.pbMessage(_INTL("You cannot deposit your last pokemon in "+
            "your party!"))
            return
          end
        end
        Graphics.freeze
        scene = GTSWantedData.new
        @sprites["background"].dispose
        data = scene.main
        create_spriteset
        Graphics.transition
        if GTSCore.uploadPokemon(pkmn, data)
          $PokemonGlobal.onlinePokemon = pkmn.clone
          if choice[0] >= 0
            $PokemonStorage[choice[0]][choice[1]] = nil
          else
            pbRemovePokemonAt(choice[1])
          end
          pbSave
          @uploaded = true
          create_spriteset
        end
      end
    else
      choices = []
      choices.push(_INTL("Yes"))
      choices.push(_INTL("No"))
      command=Kernel.pbMessage("Are you sure you want to quit GTS?",choices,choices.length)
      if command == 0
        pbPlayCancelSE
        @exit = true
      end
    end
  end
end

################################################################################
# GTS Summary Scenes
# By A Dork of Pork
# Summary Modifications for GTS
################################################################################

class PokemonSummary
  
  def pbStartGTSScreen(party,partyindex)
    @scene.pbStartScene(party,partyindex)
    ret=@scene.pbGTSScene
    @scene.pbEndScene
    return ret
  end
  
  def pbStartGTSWantedScreen(party,partyindex)
    @scene.pbStartGTSWantedScene(party)
    ret=@scene.pbGTSWantedScene(party)
    @scene.pbEndScene
    return ret
  end
  
end

class PokemonSummary_Scene
  
  def pbStartGTSWantedScene(wantedData)
    @viewport=Viewport.new(0,0,Graphics.width,Graphics.height)
    @viewport.z=99999
    @party=nil
    @partyindex=0
    @pokemon=nil
    @sprites={}
    pk = PokeBattle_Pokemon.new(wantedData[0], 1)
    @typebitmap=AnimatedBitmap.new(_INTL("Graphics/Pictures/types"))
    @sprites["background"]=IconSprite.new(0,0,@viewport)
    @sprites["overlay"]=BitmapSprite.new(Graphics.width,Graphics.height,@viewport)
    @sprites["pokemon"]=PokemonSprite.new(@viewport)
    @sprites["pokemon"].setPokemonBitmap(pk)
    @sprites["pokemon"].mirror=false
    @sprites["pokemon"].color=Color.new(0,0,0,0)
    pbPositionPokemonSprite(@sprites["pokemon"],40,144)
    @sprites["pokeicon"]=PokemonBoxIcon.new(pk,@viewport)
    @sprites["pokeicon"].x=14
    @sprites["pokeicon"].y=52
    @sprites["pokeicon"].mirror=false
    @sprites["pokeicon"].visible=false
    @sprites["movepresel"]=MoveSelectionSprite.new(@viewport)
    @sprites["movepresel"].visible=false
    @sprites["movepresel"].preselected=true
    @sprites["movesel"]=MoveSelectionSprite.new(@viewport)
    @sprites["movesel"].visible=false
    @page=0
    drawPageOneGTSWanted(wantedData)
    pbFadeInAndShow(@sprites) { pbUpdate }
  end
  
  def pbGTSScene
    pbPlayCry(@pokemon)
    loop do
      Graphics.update
      Input.update
      pbUpdate
      if Input.trigger?(Input::B)
        if Kernel.pbConfirmMessage(_INTL("Stop looking for a pokemon?"))
          return false
        end
      end
      dorefresh=false
      if Input.trigger?(Input::C)
          if Kernel.pbConfirmMessage(_INTL("Is this the pokemon you want?"))
            break
          end
      end
      if Input.trigger?(Input::UP) && @partyindex>0
        pbGoToPrevious
        @pokemon=@party[@partyindex]
        @sprites["pokemon"].setPokemonBitmap(@pokemon)
        @sprites["pokemon"].color=Color.new(0,0,0,0)
        pbPositionPokemonSprite(@sprites["pokemon"],40,144)
        dorefresh=true
        pbPlayCry(@pokemon)
      end
      if Input.trigger?(Input::DOWN) && @partyindex<@party.length-1
        pbGoToNext
        @pokemon=@party[@partyindex]
        @sprites["pokemon"].setPokemonBitmap(@pokemon)
        @sprites["pokemon"].color=Color.new(0,0,0,0)
        pbPositionPokemonSprite(@sprites["pokemon"],40,144)
        dorefresh=true
        pbPlayCry(@pokemon)
      end
      if Input.trigger?(Input::LEFT) && !@pokemon.egg?
        oldpage=@page
        @page-=1
        @page=0 if @page<0
        @page=4 if @page>4
        dorefresh=true
        if @page!=oldpage # Move to next page
          pbPlayCursorSE()
          dorefresh=true
        end
      end
      if Input.trigger?(Input::RIGHT) && !@pokemon.egg?
        oldpage=@page
        @page+=1
        @page=0 if @page<0
        @page=4 if @page>4
        if @page!=oldpage # Move to next page
          pbPlayCursorSE()
          dorefresh=true
        end
      end
      if dorefresh
        case @page
          when 0
            drawPageOne(@pokemon)
          when 1
            drawPageTwo(@pokemon)
          when 2
            drawPageThree(@pokemon)
          when 3
            drawPageFour(@pokemon)
          when 4
            drawPageFive(@pokemon)
        end
      end
    end
    return @partyindex
  end
  
  def pbGTSWantedScene(wantedData)
    pbPlayCry(wantedData[0])
    loop do
      Graphics.update
      Input.update
      pbUpdate
      if Input.trigger?(Input::B)
        if Kernel.pbConfirmMessage(_INTL("Decline this trade?"))
          return false
        end
      end
      dorefresh=false
      if Input.trigger?(Input::C)
        if Kernel.pbConfirmMessage(_INTL("Accept this trade?"))
          return true
        end
      end
      if dorefresh
        drawPageOneGTSWanted(wantedData)
      end
    end
  end
  
  def drawPageOneGTSWanted(wantedData)
    pokemon = PokeBattle_Pokemon.new(wantedData[0], 1)
    overlay=@sprites["overlay"].bitmap
    overlay.clear
    bit = "Graphics/Pictures/summaryGTS"
    bit = "Graphics/Pictures/summary1" if !pbResolveBitmap(bit)
    g = "Either"
    g = "Male" if wantedData[3] == 0
    g = "Female" if wantedData[3] == 1
    @sprites["background"].setBitmap(bit)
    base=Color.new(248,248,248)
    shadow=Color.new(104,104,104)
    numberbase=Color.new(64,64,64)
    numbershadow=Color.new(176,176,176)
    pbSetSystemFont(overlay)
    pokename = PBSpecies.getName(wantedData[0])
    imagepos=[]
    textpos=[
       [_INTL("WANTED INFO"),26,16,0,base,shadow],
       [_ISPRINTF("Dex No."),238,80,0,base,shadow],
       [_ISPRINTF("{1:03d}",wantedData[0]),435,80,2,numberbase,numbershadow],
       [_INTL("Species"),238,112,0,base,shadow],
       [_INTL("{1}",pokename),435,112,2,Color.new(64,64,64),Color.new(176,176,176)],
       [_INTL("Type"),238,144,0,base,shadow],
       [_INTL("Level"),238,176,0,base,shadow],
       [_INTL("{1} to {2}",wantedData[1], wantedData[2]),390,176,0,
       Color.new(64,64,64),Color.new(176,176,176)],
       [_INTL("Gender"),238,208,0,base,shadow],
       [_INTL("{1}",g),435,208,2,Color.new(64,64,64),Color.new(176,176,176)],
    ]
    pbDrawTextPositions(overlay,textpos)
    type1rect=Rect.new(0,pokemon.type1*28,64,28)
    type2rect=Rect.new(0,pokemon.type2*28,64,28)
    if pokemon.type1==pokemon.type2
      overlay.blt(402,146,@typebitmap.bitmap,type1rect)
    else
      overlay.blt(370,146,@typebitmap.bitmap,type1rect)
      overlay.blt(436,146,@typebitmap.bitmap,type2rect)
    end
  end
end

################################################################################
# GTS Core
# By A Dork of Pork
# Core GTS functions (Basically this is what you need to make a complete GTS
# system)
################################################################################

module GTSCore
  
  # Tests connection to the server (not used anymore but kept for possible use)
  def self.testConnection
    x = execute("test")
    return x != ""
  rescue
    return false
  end
  
  # Our main execution method, since I'm too lazy to write GTSSettings::URL a lot
  def self.execute(action, data={})
    data["action"]=action
    return pbPostData(GTSSettings::URL+GTSSettings::GAMEID.to_s, data)
  end
  
  # gets a new online ID from the server
  def self.getOnlineID
    r = execute("getOnlineID")
    return r.to_i
  end
  
  # registers our new online ID to the server
  def self.setOnlineID(id)
    r = execute("setOnlineID", {"id" => id})
    ret = r == "success"
    print "GTS Error: #{r}" if !ret && $DEBUG
    return ret
  end
  
  # checks whether you have a pokemon uploaded in the server
  def self.hasPokemonUploaded?(id=$PokemonGlobal.onlineID)
    r = execute("hasPokemonUploaded", {"id" => id})
    e = !(r == "yes" || r == "no")
    print "GTS Error: #{r}" if e && $DEBUG
    return r == "yes"
  end
  
  # sets the pokemon with the given online ID to taken
  def self.setTaken(id)
    r = execute("setTaken", {"id" => id})
    e = !r == "success"
    print "GTS Error: #{r}" if e && $DEBUG
    return r == "success"
  end
  
  # checks wether the pokemon with the give online ID is taken
  def self.isTaken(id=$PokemonGlobal.onlineID)
    r = execute("isTaken", {"id" => id})
    e = !(r == "yes" || r == "no")
    print "GTS Error: #{r}" if e && $DEBUG
    return r == "yes"
  end
  
  # uploads a pokemon to the server
  def self.uploadPokemon(pokemon, *wantedData)
    if wantedData[0].is_a?(Array)
      wantedData = wantedData[0]
    end
    pokemon.game_code = GTSSettings::GAME_CODE
    r = execute("uploadPokemon", {"id" => $PokemonGlobal.onlineID,
    "pokemon" => pokemon, "species" => pokemon.species,"level" => pokemon.level,
    "gender" => pokemon.gender, "Wspecies" => wantedData[0],
    "WlevelMin" => wantedData[1], "WlevelMax" => wantedData[2],
    "Wgender" => wantedData[3]})
    ret = r == "success"
    print "GTS Error: #{r}" if !ret && $DEBUG
    return ret
  end
  
  # uploads the newly traded pokemon to the given online ID to the server
  def self.uploadNewPokemon(id, pokemon)
    pokemon.game_code = GTSSettings::GAME_CODE
    r = execute("uploadNewPokemon", {"id" => id, "pokemon" => pokemon})
    ret = r == "success"
    print "GTS Error: #{r}" if !ret && $DEBUG
    return ret
  end
  
  # downloads a pokemon string with the given online ID
  def self.downloadPokemon(id)
    r = execute("downloadPokemon", {"id" => id})
    ret = r != ""
    print "GTS Error: #{r}" if !ret && $DEBUG
    return ret ? r : false
  end
  
  # downloads the wanted data with the given online ID
  def self.downloadWantedData(id)
    r = execute("downloadWantedData", {"id" => id})
    ret = r != ""
    print "GTS Error: #{r}" if !ret && $DEBUG
    return ret ? r.split(",") : false
  end
  
  # deletes your current pokemon from the server
  def self.deletePokemon(withdraw = true)
    r = execute("deletePokemon", {"id" => $PokemonGlobal.onlineID,
    "withdraw" => withdraw ? "y" : "n"})
    ret = r == "success"
    print "GTS Error: #{r}" if !ret && $DEBUG
    return ret
  end
  
  # gets a list of online IDs where the wanted data match up
  def self.getPokemonList(*wantedData)
    if wantedData[0].is_a?(Array)
      wantedData = wantedData[0]
    end
    r = execute("getPokemonList", {"id" => $PokemonGlobal.onlineID,
    "species" => wantedData[0], "levelMin" => wantedData[1],
    "levelMax" => wantedData[2], "gender" => wantedData[3]})
    return [r] if r == "nothing"
    if (r.include?("/,,,/"))
      return r.split("/,,,/")
    else
      return r.split(",")
    end
  end
  
  # Reverse Lookup pokemon
  def self.getPokemonListFromWanted(pokemon)
    r = execute("getPokemonListFromWanted", {"id" => $PokemonGlobal.onlineID,
    "species" => pokemon.species, "level" => pokemon.level,
    "gender" => pokemon.gender})
    return [r] if r == "nothing"
    if (r.include?("/,,,/"))
      return r.split("/,,,/")
    else
      return r.split(",")
    end
  end
  
  # installs the MYSQL tables in the server
  def self.install
    return execute("createTables")
  end
end

################################################################################
# Addons
# By A Dork of Pork (pokemon to string and string to pokemon based from Maruno's
#             MysteryGift packer/unpacker)
# Addons to other scripts
################################################################################
class PokemonGlobalMetadata
  attr_accessor :onlineID
  attr_accessor :onlinePokemon
  attr_accessor :keepGTS
  
  alias gts_initialize initialize
  # Keep your old online ID when doing newgame to prevent "spamming" the server
  def initialize
    gts_initialize
    
    return if !GTSSettings::KEEP_OLD_IDS # return before we get your old ID back
    
    save = RTP.getSaveFileName("Game.rxdata")
    if FileTest.exist?(save)
      file = File.open(save, "rb")
      Marshal.load(file)
      Marshal.load(file)
      Marshal.load(file)
      Marshal.load(file)
      Marshal.load(file)
      Marshal.load(file)
      Marshal.load(file)
      Marshal.load(file)
      Marshal.load(file)
      Marshal.load(file)
      Marshal.load(file)
      pg = Marshal.load(file)
      file.close
      @onlineID = pg.rawOnlineID
    end
    @keepGTS = false
  end
  
  def onlineID
    if @onlineID == nil
      id = GTSCore.getOnlineID
      if id == 0
        raise("GTS Error: Cannot get Online ID for GTS!")
      end
      if !GTSCore.setOnlineID(id)
        raise("GTS Error: Cannot set Online ID for GTS!")
      end
      @onlineID = id
    end
    return @onlineID
  end
  
  # The rawOnlineID doesn't have the checksum to get a new ID, this is used for
  # when you do new game.
  def rawOnlineID
    if @onlineID
      return @onlineID
    else
      return nil
    end
  end
end

# Add a game_code field and to_s method to the pokemon class
class PokeBattle_Pokemon
  attr_accessor :game_code
  def to_s
    ret=[Zlib::Deflate.deflate(Marshal.dump(self))].pack("m")
    return ret
  end
end

# Add a to_pokemon method to the string class
class String
  def to_pokemon
    ret=Marshal.restore(Zlib::Inflate.inflate(unpack("m")[0]))
    return ret
  end
end

# Delete Pokemon if we began a newgame
alias pbSaveGTS pbSave
def pbSave(safesave=false)
  if GTSCore.testConnection
    if !$PokemonGlobal.keepGTS
      if GTSCore.deletePokemon
        $PokemonGlobal.keepGTS=true
      end
    end
  end
  pbSaveGTS(safesave)
end